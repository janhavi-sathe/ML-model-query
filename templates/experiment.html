{% extends 'base.html' %}

{% block title %}Experiment{% endblock %}

{% block header %}
  <h1>Experiment 1</h1>
{% endblock %}

{% block content %}
    <script src="//code.jquery.com/jquery-1.12.4.min.js" integrity="sha256-ZosEbRLbNQzLpnKIkEdrPv7lOy9C27hHQ+Xp8a4MxAQ=" crossorigin="anonymous"></script>
    <script src="//cdnjs.cloudflare.com/ajax/libs/socket.io/2.2.0/socket.io.js" integrity="sha256-yr4fRk/GU1ehYJPAs8P4JlTgu0Hdsp4ZKrx8bDEDC3I=" crossorigin="anonymous"></script>
    <script type="text/javascript" charset="utf-8">
        $(document).ready(function() {
          // Connect to the Socket.IO server.
          var socket = io();

          socket.on('connect', function() {
              socket.emit('my_echo', {data: 'I\'m connected!'});
          });


          var grid_x, grid_y;
          function idx2coord(idx) {
            var x_tmp = idx % grid_x;
            var y_tmp = Math.floor(idx / grid_x);
            return [x_tmp, y_tmp];
          }

          var goals;
          socket.on('init_canvas', function(json_msg) {
              var env = JSON.parse(json_msg);
              grid_x = env.grid_x;
              grid_y = env.grid_y;
              goals = env.goals;
              ctx.clearRect(0, 0, cnvs.width, cnvs.height);
              draw_start_button();
          });

          socket.on('my_response', function(msg, cb) {
              $('#log').text($('<div/>').text('Received #' + msg.count + ': ' + msg.data).html());
              if (cb) {
                  cb();
              }
          });

          // var ping_start_time;
          // socket.on('my_pong', function() {
          //       var latency = (new Date).getTime() - ping_start_time;
          //       $('#ping-pong').text(Math.round(10 * latency) / 10);
          //   });

          // $('form#ping').submit(function(event) {
          //     ping_start_time = (new Date).getTime();
          //     socket.emit('my_ping');
          //     return false;
          // });

          // $('form#echo').submit(function(event) {
          //     socket.emit('my_echo', {data: $('#emit_data').val()});
          //     return false;
          // });

          var app_running = 0;
          var cnvs = document.getElementById("myCanvas");
          var ctx = cnvs.getContext("2d");
          cnvs.addEventListener('keydown', doKeyDown, true);
          cnvs.addEventListener('click', onClick, true);

          var cur_key = "None";
          function doKeyDown(e){
            if (app_running == 1){
              cur_key = e.key
              document.getElementById("keyname").innerHTML = e.key;
              // socket.emit('keydown_event', {data: e.keyCode});
            }
            // alert(e.keyCode);
          }            

          function sendAction() {
              clearInterval(count_down);
              document.getElementById("timer").innerHTML = 0;
              socket.emit('keydown_event', {data: cur_key});
              // reset key
              cur_key = "None"
              document.getElementById("keyname").innerHTML = cur_key;
          }

          function onClick(event){
            if (app_running == 0) {               
              var x_m = event.clientX - cnvs.getBoundingClientRect().left;
              var y_m = event.clientY - cnvs.getBoundingClientRect().top;
              var x_center = cnvs.width / 2;
              var y_center = cnvs.height / 2;
              if (x_m > x_center - 100 && x_m < x_center + 100 && y_m > y_center - 30 && y_m < y_center + 30) {
                socket.emit('run_experiment', {data: {{ cur_user }} });
                console.log("Run");
              }
            }
          }

          function conv_x(fX) {
            return Math.round(fX / grid_x * cnvs.width);
          }
          function conv_y(fY) {
            return Math.round(fY / grid_y * cnvs.height);
          }
          function draw_grid_line() {
            ctx.fillStyle = "yellow";
            for (const idx of goals) {
              let coord = idx2coord(idx);
              let x_corner = conv_x(coord[0]);
              let y_corner = conv_y(coord[1]);
              let wdth = conv_x(1);
              let hght = conv_y(1);
              ctx.fillRect(x_corner, y_corner, wdth, hght);
            }
            ctx.strokeStyle = "black";
            ctx.setLineDash([5, 5]);
            for (i = 1; i < grid_x; i++) {
              ctx.beginPath();
              ctx.moveTo(conv_x(i), 0);
              ctx.lineTo(conv_x(i), cnvs.height);
              ctx.stroke();
            }
            for (i = 1; i < grid_y; i++) {
              ctx.beginPath();
              ctx.moveTo(0, conv_y(i));
              ctx.lineTo(cnvs.width, conv_y(i));
              ctx.stroke();
            }
            ctx.setLineDash([]);
          }

          function countDown(){
            let time_diff = Date.now() - timer_start;
            if (time_diff < action_duration) {
              document.getElementById("timer").innerHTML = action_duration - time_diff;
            }
          }

          function draw_start_button() {
            ctx.strokeStyle = "black";
            ctx.fillStyle = "black";
            ctx.beginPath();
            var x_center = cnvs.width / 2;
            var y_center = cnvs.height / 2;
            ctx.moveTo(x_center - 100, y_center - 30);
            ctx.lineTo(x_center + 100, y_center - 30);
            ctx.lineTo(x_center + 100, y_center + 30);
            ctx.lineTo(x_center - 100, y_center + 30);
            ctx.closePath();
            ctx.stroke();

            ctx.textAlign = "center";
            ctx.font = "bold 20px arial";
            ctx.fillText("Click To Start", x_center, y_center);
          }
          var timer_start;
          var count_down;
          const action_duration = 1000;
          socket.on('draw_canvas', function(json_msg) {
              // console.log("draw draw");
              app_running = 1;
              var obj_json = JSON.parse(json_msg);
              ctx.clearRect(0, 0, cnvs.width, cnvs.height);
              draw_grid_line();
              let a1_idx = obj_json.a1_pos;
              let a2_idx = obj_json.a2_pos;
              let a1_hold = obj_json.a1_hold;
              let a2_hold = obj_json.a2_hold;

              ctx.fillStyle = "black";
              const mar = 0.2
              let overlap_bags = []
              for (const idx of obj_json.bags) {
                if (idx == a1_idx || idx == a2_idx) {
                  overlap_bags.push(idx);
                } else {
                  let coord = idx2coord(idx);
                  let x_c = conv_x(coord[0] + mar);
                  let y_c = conv_y(coord[1] + mar);
                  let wdth = conv_x(1 - 2 * mar);
                  let hght = conv_y(1 - 2 * mar);
                  ctx.fillRect(x_c, y_c, wdth, hght);
                }
              }

              let a1_pos = idx2coord(a1_idx);
              let a2_pos = idx2coord(a2_idx);

              if (a1_hold == 1) {
                ctx.fillStyle = "red";
                let x_c = conv_x(a1_pos[0] + 0.5);
                let y_c = conv_y(a1_pos[1] + mar);
                let rad = conv_x(mar);
                ctx.beginPath();
                ctx.arc(x_c, y_c, rad, 0, 2 * Math.PI);
                ctx.fill();
              }
              if (a2_hold == 1) {
                ctx.fillStyle = "blue";
                let x_c = conv_x(a2_pos[0] + 0.5);
                let y_c = conv_y(a2_pos[1] + 1 - mar);
                let rad = conv_x(mar);
                ctx.beginPath();
                ctx.arc(x_c, y_c, rad, 0, 2 * Math.PI);
                ctx.fill();
              }

              ctx.fillStyle = "black";
              for (const idx of overlap_bags) {
                let coord = idx2coord(idx);
                let x_c = conv_x(coord[0] + mar);
                let y_c = conv_y(coord[1] + mar);
                let wdth = conv_x(1 - 2 * mar);
                let hght = conv_y(1 - 2 * mar);
                ctx.fillRect(x_c, y_c, wdth, hght);
              }

              if (a1_hold == 0) {
                ctx.fillStyle = "red";
                let x_c = conv_x(a1_pos[0] + 0.5);
                let y_c = conv_y(a1_pos[1] + mar);
                let rad = conv_x(mar);
                ctx.beginPath();
                ctx.arc(x_c, y_c, rad, 0, 2 * Math.PI);
                ctx.fill();
              }
              if (a2_hold == 0) {
                ctx.fillStyle = "blue";
                let x_c = conv_x(a2_pos[0] + 0.5);
                let y_c = conv_y(a2_pos[1] + 1 - mar);
                let rad = conv_x(mar);
                ctx.beginPath();
                ctx.arc(x_c, y_c, rad, 0, 2 * Math.PI);
                ctx.fill();
              }

              // once all elements are drawn, set timer.
              timer_start = Date.now();
              // console.log(timer_start)
              setTimeout(sendAction, action_duration);
              count_down = setInterval(countDown, 200);
            }); 

          socket.on('game_end', function(){
            if (app_running == 1) {
              app_running = 0
              // console.log(app_running)
              ctx.clearRect(0, 0, cnvs.width, cnvs.height);
              draw_start_button(); 
              }
            });
        });

    </script>
   <!-- <h2>Connection Check</h2>
    <form id="ping" method="POST" action='#' style="display: inline;">
        <input type="submit" value="Ping">
    </form>
    <b><span id="ping-pong"></span> ms</b>
    <form id="echo" method="POST" action='#'>
        <input type="text" name="emit_data" id="emit_data" placeholder="Message" style="width: 300px;" style="display: inline;">
        <input type="submit" value="Echo" style="display: inline;">
    </form> -->
    <br>
    <div id="log"></div>
    <p id="timer">Count down</p>
    <p id="keyname">Key input</p>
    <canvas id="myCanvas" width="300" height="300" style="border:1px solid #000000;" tabindex='1'>
    </canvas>
    <p> Move: left, right, up, down arrows | Pick-up: p | Drop: p | Stay: o</p>
    <p> To remove Yellow, both players should enter the Remove key together </p>
    <br>
    <h3>Please do not click below hyperlink until you finish the experiment.</h3>
    <h2><a href="{{ url_for('instruction') }}">Prev</a>    
      <a href="{{ url_for('survey.inexperiment') }}">Next</a></h2>

{% endblock %}
